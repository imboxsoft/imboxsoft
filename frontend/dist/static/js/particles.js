export let Particles=function(){window.requestAnimFrame=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame,window.cancelRequestAnimFrame=window.cancelAnimationFrame||window.webkitCancelRequestAnimationFrame||window.mozCancelRequestAnimationFrame||window.oCancelRequestAnimationFrame||window.msCancelRequestAnimationFrame;class t{#t;#i;#s;#e;#n;#a=[];#o=null;#h;constructor(t,i){this.#t=$(t),this.#i=this.#t[0],this.#s=this.#i.getContext("2d"),this.#e=this.#t.width(),this.#n=this.#t.height(),this.#i.width=this.#e,this.#i.height=this.#n,this.#h=i;let s=this;this.updateCanvas=this.updateCanvas.bind(this),$(window).on("resize",(function(t){s.updateCanvasSize()}))}getCanvasRefs(){return{canvasDomRef:this.#t,canvas:this.#i,context:this.#s}}getCanvasWidth(){return this.#e}getCanvasHeight(){return this.#n}updateCanvasSize(){this.#e=this.#t.width(),this.#n=this.#t.height(),this.#i.width=this.#e,this.#i.height=this.#n}addPoint(t){this.#a.push(t)}getPoints(){this.#a}clearCanvas(){this.#s.clearRect(0,0,this.#i.width,this.#i.height)}determineClusters(){for(let t of this.#a)for(let i of this.#a)t!==i&&t.connectNewPoint(i)}updateCanvas(t){if(null!=this.#o){const i=t-this.#o,s=1e3/this.#h;if(i>s){this.determineClusters(),this.clearCanvas();for(let t of this.#a)t.movePointAtFrame(),t.drawPointOnCanvas(),t.drawLinesToNeighbourPointsOnCanvas()}this.#o=t-i%s}else this.#o=t;window.requestAnimFrame(this.updateCanvas)}startAnimation(){window.requestAnimFrame(this.updateCanvas)}cancelAnimation(){window.cancelRequestAnimFrame(this.updateCanvas)}}class i{#i;#c=[];#r=25;constructor(t,i="#fff",s="#fff",e=7,n=25){this.#r=n,this.reverse=1,this.minDirectionAngle=0,this.maxDirectionAngle=360,this.directionAngle=Math.floor(Math.random()*(this.maxDirectionAngle-this.minDirectionAngle)+this.minDirectionAngle),this.minDistance=.5,this.maxDistance=3,this.distance=Math.random()*(this.maxDistance-this.minDistance)+this.minDistance,this.minDiameter=3,this.maxDiameter=7,this.diameter=Math.floor(Math.random()*(this.maxDiameter-this.minDiameter)+this.minDiameter),this.positionX=Math.random()*t.getCanvasWidth(),this.positionY=Math.random()*(t.getCanvasHeight()-this.#r),this.#i=t,this.numberOfNeighbours=e,this.pointColor=i,this.lineColor=function(t){t=t.replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i,((t,i,s,e)=>i+i+s+s+e+e));const i=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(t);return i?{r:parseInt(i[1],16),g:parseInt(i[2],16),b:parseInt(i[3],16)}:null}(s),this.lineFrameOpacityStep=.025,this.lineFrameDuration=250,this.lineWidth=1,this.#i.addPoint(this),this.drawPointOnCanvas()}static isPointOutsideTheBounds(t,i,s=0){const e=i.getBoundingClientRect();return t.positionX<-s||t.positionX>e.right-e.left+s||t.positionY<-s||t.positionY>e.bottom-e.top-s}calculateDistance(t,i){const s=t.positionX-i.positionX,e=t.positionY-i.positionY;return Math.sqrt(s*s+e*e)}connectNewPoint(t){if(this.#c.length<this.numberOfNeighbours)return void this.#c.push(t);let i=0,s=0;for(let[t,e]of this.#c.entries()){let n=this.calculateDistance(this,e);n>i&&(i=n,s=t)}const e=this.calculateDistance(this,t);e<i&&e>=150&&e<=300&&(this.#c[s]=t)}movePointAtFrame(){const t=this.directionAngle;let s,e,n=t*Math.PI/180;switch(t>=0&&t<=90?1:t>=90&&t<=180?2:t>=180&&t<=270?3:4){case 1:s=Math.sin(n)*this.distance,e=Math.cos(n)*this.distance,this.positionX+=this.reverse*s,this.positionY-=this.reverse*e;break;case 2:n=(t-90)*Math.PI/360,s=Math.sin(n)*this.distance,e=Math.cos(n)*this.distance,this.positionX-=this.reverse*s,this.positionY-=this.reverse*e;break;case 3:n=(t-180)*Math.PI/360,s=Math.sin(n)*this.distance,e=Math.cos(n)*this.distance,this.positionX-=this.reverse*e,this.positionY+=this.reverse*s;break;case 4:n=(t-270)*Math.PI/360,s=Math.sin(n)*this.distance,e=Math.cos(n)*this.distance,this.positionX+=this.reverse*s,this.positionY+=this.reverse*e}i.isPointOutsideTheBounds(this,this.#i.getCanvasRefs().canvas,this.#r)&&(this.reverse*=-1)}drawPointOnCanvas(){const t=this.#i.getCanvasRefs().canvas,i=this.#i.getCanvasRefs().context,s=(t.getBoundingClientRect(),this.positionX),e=this.positionY;i.fillStyle=this.pointColor,i.beginPath(),i.arc(s,e,this.diameter/2,0,2*Math.PI),i.fill(),i.closePath()}drawLinesToNeighbourPointsOnCanvas(){const t=this.#i.getCanvasRefs().canvas,i=this.#i.getCanvasRefs().context;function s(t,s,e=.025){i.beginPath(),i.moveTo(t.positionX,t.positionY),i.lineTo(s.positionX,s.positionY),i.strokeStyle=`rgba(${t.lineColor.r}, ${t.lineColor.g}, ${t.lineColor.b}, ${e})`,i.lineWidth=t.lineWidth,i.stroke(),i.closePath()}t.getBoundingClientRect(),this.positionX,this.positionY,function t(i,e,n){const a=Date.now()-e,o=i.lineFrameDuration;for(let t of n)s(i,t,i.lineFrameOpacityStep);a<o?window.requestAnimFrame((()=>t(i,e,n))):window.cancelRequestAnimFrame((()=>t(i,e,n)))}(this,Date.now(),this.#c)}}let s;return{init:function(e,n="#fff",a="#fff",o=60,h=150,c=7){s=new t(e,o);for(let t=0;t<h;t++)new i(s,n,a,c,25)},start:function(){s.startAnimation()},cancel:function(){s.cancelAnimation()}}}();